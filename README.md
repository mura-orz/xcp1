# XCP-1 - single-file xxx c++ compiler

## Introduction

- It may become a simple and tiny C++ compiler in future.
- It confirms to C++ of ISO/IEC 14882:2024 (C++23).

## Concepts & Notice of disclaimer

- It is copyrighted by Mura. (c) 2023-, Mura. All rights reserved.
- It is not Free Software.
- It is not granted for any use to any others.
- It is just only for my hobby.
- It designates to simple use of modern C++23.
- It cannot always satisfy all the requirements on actual usages.
- It is not efficient for actual purpose.
- It is just "as is" and no warranty and no guarantee for any use and damage of any one.
- It complies with the laws and regulations of Japan.

## Environments

### Build environments

- It can be built by modern C++23 compilers and standard libraries: e.g.,
  - GNU g++ / libstdc++
  - LLVM clang++ / libc++ (It fails to compile currently because it has not supported std::source_location well yet.)
  - Visual C++
- It can be built on the "hosted" environments. e.g.,
  - 32/64bit Windows
  - 32/64bit Linux

### Runtime environments

- Same environment as the environment it was built

## Usage

> $ ./xcp (options) sources

### Options

- -h Shows usage only.
- -v Shows version.
- -D:{Macro} Defines the {Macro} as the value 1
- -D:{Macro}={Value} Defines the {Macro} as the {value}
- -I:{Path} Adds the including path {Path} to find headers.
- -L:{Path} Adds the linkage path {Path} to find.libraries.
- -l:{name} Links the library {name}.

## Design

- It expects source code is formatted in UTF-8.
- All the source codes are loaded on memory once.
- Lexical parsing uses regex simply even if it is too slower than tuned parser.
- The source codes are held as string and are referred as string_view while syntax parsing.
- Predefined macros are also held as another string and are referred as string_view while syntax parsing.
- These strings are read only. But macro expansion should modify them.
  For that, the macro expansion generates another modified string.
- Position of tokens are stored during lexical parsing. The #line directive also modifies them.
  For that, the #line modifies all the tokens directly because #line directive is assumed to rarely in typical usage.
- The lexical parser parses raw string to flat sequence of the tokens at first.
  After that, the lexer splits the flat sequence to nested sequence as 'lines' for preprocessing.
- Preprocessor executes directives and expands macros for each line.
  preprocessing should be applied for each line and line sequentially
  because such directives as #define,#undef,and #include affects results of macro expansion after the line.
- Preprocessing has been completed, the tokens become flat sequence again.
- Then syntax parser makes an abstract syntax tree (AST) using PEG-like parsers.

## Grammar

### A.2 Keywords [gram.key]

- typedef-name:
  - identifier
  - simple-template-id
- namespace-name:
  - identifier
  - namespace-alias
- namespace-alias:
  - identifier
- class-name:
  - identifier
  - simple-template-id
- enum-name:
  - identifier
- enumerator-name:
  - identifier

### A.3 Lexical conventions

- n-char: one of
  - any member of the translation character set except the U+007D RIGHT CURLY BRACKET or new-line character
- n-char-sequence:
  - n-char
  - n-char-sequence n-char
- named-universal-character:
  - \N{ n-char-sequence }
- hex-quad:
  - hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
- simple-hexadecimal-digit-sequence:
  - hexadecimal-digit
  - simple-hexadecimal-digit-sequence hexadecimal-digit
- universal-character-name:
  - \u hex-quad
  - \U hex-quad hex-quad
  - \u{ simple-hexadecimal-digit-sequence }
  - named-universal-character
- preprocessing-token:
  - header-name
  - import-keyword
  - module-keyword
  - export-keyword
  - identifier
  - pp-number
  - character-literal
  - user-defined-character-literal
  - string-literal
  - user-defined-string-literal
  - preprocessing-op-or-punc
  - each non-whitespace character that cannot be one of the above
- token:
  - identifier
  - literal
  - operator-or-punctuator
- header-name:
  - < h-char-sequence >
  - " q-char-sequence "
- h-char-sequence:
  - h-char
  - h-char-sequence h-char
- h-char:
  - any member of the translation character set except new-line and U+003E GREATER-THAN SIGN
- q-char-sequence:
  - q-char
  - q-char-sequence q-char
- q-char:
  - any member of the translation character set except new-line and U+0022 QUOTATION MARK
- pp-number:
  - digit
  - . digit
  - pp-number identifier-continue
  - pp-number ’ digit
  - pp-number ’ nondigit
  - pp-number e sign
  - pp-number E sign
  - pp-number p sign
  - pp-number P sign
  - pp-number .
- identifier:
  - identifier-start
  - identifier identifier-continue
- identifier-start:
  - nondigit
  - an element of the translation character set with the Unicode property XID_Start
- identifier-continue:
  - digit
  - nondigit
  - an element of the translation character set with the Unicode property XID_Continue
- nondigit: one of
  - a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \_
- digit: one of
  - 0 1 2 3 4 5 6 7 8 9
- keyword:
  - any identifier listed in Table 5
  - import-keyword
  - module-keyword
  - export-keyword
- preprocessing-op-or-punc:
  - preprocessing-operator
  - operator-or-punctuator
- preprocessing-operator: one of
  - \# ## %: %:%:
- operator-or-punctuator: one of
  - { } [ ] ( ) <: :> <% %> ; : ... ? :: . .\* -> ->\* ~ ! + - \* / % ^ & | = += -= \*= /= %= ^= &= |= == != < > <= >= <=> && || << >> <<= >>= ++ -- , and or xor not bitand bitor compl and_eq or_eq xor_eq not_eq
- literal:
  - integer-literal
  - character-literal
  - floating-point-literal
  - string-literal
  - boolean-literal
  - pointer-literal
  - user-defined-literal
- integer-literal:
  - binary-literal integer-suffix?
  - octal-literal integer-suffix?
  - decimal-literal integer-suffix?
  - hexadecimal-literal integer-suffix?
- binary-literal:
  - 0b binary-digit
  - 0B binary-digit
  - binary-literal ’? binary-digit
- octal-literal:
  - 0
  - octal-literal ’? octal-digit
- decimal-literal:
  - nonzero-digit
  - decimal-literal ’? digit
- hexadecimal-literal:
  - hexadecimal-prefix hexadecimal-digit-sequence
- binary-digit: one of
  - 0 1
- octal-digit: one of
  - 0 1 2 3 4 5 6 7
- nonzero-digit: one of
  - 1 2 3 4 5 6 7 8 9
- hexadecimal-prefix: one of
  - 0x 0X
- hexadecimal-digit-sequence:
  - hexadecimal-digit
  - hexadecimal-digit-sequence ’? hexadecimal-digit
- hexadecimal-digit: one of
  - 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
- integer-suffix:
  - unsigned-suffix long-suffix?
  - unsigned-suffix long-long-suffix?
  - unsigned-suffix size-suffix?
  - long-suffix unsigned-suffix?
  - long-long-suffix unsigned-suffix?
  - size-suffix unsigned-suffix?
- unsigned-suffix: one of
  - u U
- long-suffix: one of
  - l L
- long-long-suffix: one of
  - ll LL
- size-suffix: one of
  - z Z
- character-literal:
  - encoding-prefix? ’ c-char-sequence ’
- encoding-prefix: one of
  - u8 u U L
- c-char-sequence:
  - c-char
  - c-char-sequence c-char
- c-char:
  - basic-c-char
  - escape-sequence
  - universal-character-name
- basic-c-char:
  - any member of the translation character set except the U+0027 APOSTROPHE, U+005C REVERSE SOLIDUS, or new-line character
- escape-sequence:
  - simple-escape-sequence
  - numeric-escape-sequence
  - conditional-escape-sequence
- simple-escape-sequence:
  - \ simple-escape-sequence-char
- simple-escape-sequence-char: one of
  - ’ " ? \ a b f n r t v
- numeric-escape-sequence:
  - octal-escape-sequence
  - hexadecimal-escape-sequence
- simple-octal-digit-sequence:
  - octal-digit
  - simple-octal-digit-sequence octal-digit
- octal-escape-sequence:
  - \ octal-digit
  - \ octal-digit octal-digit
  - \ octal-digit octal-digit octal-digit
  - \o{ simple-octal-digit-sequence }
- hexadecimal-escape-sequence:
  - \x simple-hexadecimal-digit-sequence
  - \x{ simple-hexadecimal-digit-sequence }
- conditional-escape-sequence:
  - \ conditional-escape-sequence-char
- conditional-escape-sequence-char:
  - any member of the basic character set that is not an octal-digit, a simple-escape-sequence-char, or the characters N, o, u, U, or x
- floating-point-literal:
  - decimal-floating-point-literal
  - hexadecimal-floating-point-literal
- decimal-floating-point-literal:
  - fractional-constant exponent-part? floating-point-suffix?
  - digit-sequence exponent-part floating-point-suffix?
- hexadecimal-floating-point-literal:
  - hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part floating-point-suffix?
  - hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part floating-point-suffix?
- fractional-constant:
  - digit-sequence? . digit-sequence
  - digit-sequence .
- hexadecimal-fractional-constant:
  - hexadecimal-digit-sequence? . hexadecimal-digit-sequence
  - hexadecimal-digit-sequence .
- exponent-part:
  - e sign? digit-sequence
  - E sign? digit-sequence
- binary-exponent-part:
  - p sign? digit-sequence
  - P sign? digit-sequence
- sign: one of
  - \+ \-
- digit-sequence:
  - digit
  - digit-sequence ’? digit
- floating-point-suffix: one of
  - f l f16 f32 f64 f128 bf16 F L F16 F32 F64 F128 BF16
- string-literal:
  - encoding-prefix? " s-char-sequence? "
  - encoding-prefix? R raw-string
- s-char-sequence:
  - s-char
  - s-char-sequence s-char
- s-char:
  - basic-s-char
  - escape-sequence
  - universal-character-name
- basic-s-char:
  - any member of the translation character set except the U+0022 QUOTATION MARK, U+005cCrREVERSE SOLIDUS, or new-line character
- raw-string:
  - " d-char-sequence? ( r-char-sequence? ) d-char-sequence? "
- r-char-sequence:
  - r-char
  - r-char-sequence r-char
- r-char:
  - any member of the translation character set, except a U+0029 RIGHT PARENTHESIS followed by the initial d-char-sequence (which may be empty) followed by a U+0022 QUOTATION MARK
- d-char-sequence:
  - d-char
  - d-char-sequence d-char
- d-char:
  - any member of the basic character set except:
    - U+0020 SPACE, U+0028 LEFT PARENTHESIS, U+0029 RIGHT PARENTHESIS, U+005cCrREVERSE SOLIDUS, U+0009 CHARACTER TABULATION, U+000B LINE TABULATION, U+000C FORM FEED, and new-line
- boolean-literal:
  - true
  - false
- pointer-literal:
  - nullptr
- user-defined-literal:
  - user-defined-integer-literal
  - user-defined-floating-point-literal
  - user-defined-string-literal
  - user-defined-character-literal
- user-defined-integer-literal:
  - decimal-literal ud-suffix
  - octal-literal ud-suffix
  - hexadecimal-literal ud-suffix
  - binary-literal ud-suffix
- user-defined-floating-point-literal:
  - fractional-constant exponent-part? ud-suffix
  - digit-sequence exponent-part ud-suffix
  - hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part ud-suffix
  - hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part ud-suffix
- user-defined-string-literal:
  - string-literal ud-suffix
- user-defined-character-literal:
  - character-literal ud-suffix

### A.4 Basics [gram.basic]

- translation-unit:
  - declaration\*
  - global-module-fragment? module-declaration declaration\* private-module-fragment?

### A.5 Expressions

- primary-expression:
  - literal
  - this
  - ( expression )
  - id-expression
  - lambda-expression
  - fold-expression
  - requires-expression
- id-expression:
  - unqualified-id
  - qualified-id
- unqualified-id:
  - identifier
  - operator-function-id
  - conversion-function-id
  - literal-operator-id
  - ~ type-name
  - ~ decltype-specifier
  - template-id
- qualified-id:
  - nested-name-specifier template? unqualified-id
- nested-name-specifier:
  - ::
  - type-name ::
  - namespace-name ::
  - decltype-specifier ::
  - nested-name-specifier identifier ::
  - nested-name-specifier template? simple-template-id ::
- lambda-expression:
  - lambda-introducer attribute-specifier\* lambda-declarator compound-statement
  - lambda-introducer < template-parameter-list > requires-clause? attribute-specifier\* lambda-declarator compound-statement
- lambda-introducer:
  - [ lambda-capture? ]
- lambda-declarator:
  - lambda-specifier+ noexcept-specifier? attribute-specifier\* trailing-return-type?
  - noexcept-specifier attribute-specifier\* trailing-return-type?
  - trailing-return-type?
  - ( parameter-declaration-clause ) lambda-specifier* noexcept-specifier? attribute-specifie* trailing-return-type? requires-clause?
- lambda-specifier:
  - consteval
  - constexpr
  - mutable
  - static
- lambda-capture:
  - capture-default
  - capture-list
  - capture-default , capture-list
- capture-default:
  - &
  - =
- capture-list:
  - capture
  - capture-list , capture
- capture:
  - simple-capture
  - init-capture
- simple-capture:
  - identifier ...?
  - & identifier ...?
  - this
  - ~ this
- init-capture:
  - ...? identifier initializer
  - & ...? identifier initializer
- fold-expression:
  - ( cast-expression fold-operator ... )
  - ( ... fold-operator cast-expression )
  - ( cast-expression fold-operator ... fold-operator cast-expression )
- fold-operator:
  - one of + - \* / % ^ & | << >> += -= \*= /= %= ^= &= |= <<= >>= = == != < > <= >= && || , .\* ->\*
- requires-expression:
  - requires requirement-parameter-list? requirement-body
- requirement-parameter-list:
  - ( parameter-declaration-clause )
- requirement-body:
  - { requirement+ }
- requirement:
  - simple-requirement
  - type-requirement
  - compound-requirement
  - nested-requirement
- simple-requirement:
  - expression ;
- type-requirement:
  - typename nested-name-specifier? type-name ;
- compound-requirement:
  - { expression } noexcept? return-type-requirement? ;
- return-type-requirement:
  - -> type-constraint
- nested-requirement:
  - requires constraint-expression ;
- postfix-expression:
  - primary-expression
  - postfix-expression [ expression-list? ]
  - postfix-expression ( expression-list? )
  - simple-type-specifier ( expression-list? )
  - typename-specifier ( expression-list? )
  - simple-type-specifier braced-init-list
  - typename-specifier braced-init-list
  - postfix-expression . template? id-expression
  - postfix-expression -> template? id-expression
  - postfix-expression ++
  - postfix-expression --
  - dynamic_cast < type-id > ( expression )
  - static_cast < type-id > ( expression )
  - reinterpret_cast < type-id > ( expression )
  - const_cast < type-id > ( expression )
  - typeid ( expression )
  - typeid ( type-id )
- expression-list:
  - initializer-list
- unary-expression:
  - postfix-expression
  - unary-operator cast-expression
  - ++ cast-expression
  - -- cast-expression
  - await-expression
  - sizeof unary-expression
  - sizeof ( type-id )
  - sizeof ... ( identifier )
  - alignof ( type-id )
  - noexcept-expression
  - new-expression
  - delete-expression
- unary-operator:
  - one of \* & + - ! ~
- await-expression:
  - co_await cast-expression
- noexcept-expression:
  - noexcept ( expression )
- new-expression:
  - ::? new new-placement? new-type-id new-initializer?
  - ::? new new-placement? ( type-id ) new-initializer?
- new-placement:
  - ( expression-list )
- new-type-id:
  - type-specifier+ new-declarator?
- new-declarator:
  - ptr-operator new-declarator?
  - noptr-new-declarator
- noptr-new-declarator:
  - [ expression? ] attribute-specifier\*
  - noptr-new-declarator [ constant-expression ] attribute-specifier\*
- new-initializer:
  - ( expression-list? )
  - braced-init-list
- delete-expression:
  - ::? delete cast-expression
  - ::? delete [ ] cast-expression
- cast-expression:
  - unary-expression
  - ( type-id ) cast-expression
- pm-expression:
  - cast-expression
  - pm-expression .\* cast-expression
  - pm-expression ->\* cast-expression
- multiplicative-expression:
  - pm-expression
  - multiplicative-expression \* pm-expression
  - multiplicative-expression / pm-expression
  - multiplicative-expression % pm-expression
- additive-expression:
  - multiplicative-expression
  - additive-expression + multiplicative-expression
  - additive-expression - multiplicative-expression
- shift-expression:
  - additive-expression
  - shift-expression << additive-expression
  - shift-expression >> additive-expression
- compare-expression:
  - shift-expression
  - compare-expression <=> shift-expression
- relational-expression:
  - compare-expression
  - relational-expression < compare-expression
  - relational-expression > compare-expression
  - relational-expression <= compare-expression
  - relational-expression >= compare-expression
- equality-expression:
  - relational-expression
  - equality-expression == relational-expression
  - equality-expression != relational-expression
- and-expression:
  - equality-expression
  - and-expression & equality-expression
- exclusive-or-expression:
  - and-expression
  - exclusive-or-expression ^ and-expression
- inclusive-or-expression:
  - exclusive-or-expression
  - inclusive-or-expression | exclusive-or-expression
- logical-and-expression:
  - inclusive-or-expression
  - logical-and-expression && inclusive-or-expression
- logical-or-expression:
  - logical-and-expression
  - logical-or-expression || logical-and-expression
- conditional-expression:
  - logical-or-expression
  - logical-or-expression ? expression : assignment-expression
- yield-expression:
  - co_yield assignment-expression
  - co_yield braced-init-list
- throw-expression:
  - throw assignment -expression?
- assignment-expression:
  - conditional-expression
  - yield-expression
  - throw-expression
  - logical-or-expression assignment-operator initializer-clause
- assignment-operator:
  - one of = \*= /= %= += -= >>= <<= &= ^= |=
- expression:
  - assignment-expression
  - expression , assignment-expression
- constant-expression:
  - conditional-expression

### A.6 Statements

- statement:
  - labeled-statement
  - attribute-specifier\* expression-statement
  - attribute-specifier\* compound-statement
  - attribute-specifier\* selection-statement
  - attribute-specifier\* iteration-statement
  - attribute-specifier\* jump-statement
  - declaration-statement
  - attribute-specifier\* try-block
- init-statement:
  - expression-statement
  - simple-declaration
  - alias-declaration
- condition:
  - expression
  - attribute-specifier\* decl-specifier+ declarator brace-or-equal-initializer
- label:
  - attribute-specifier\* identifier :
  - attribute-specifier\* case constant-expression :
  - attribute-specifier\* default :
- labeled-statement:
  - label statement
- expression-statement:
  - expression? ;
- compound-statement:
  - { statement* label* }
- selection-statement:
  - if constexpr? ( init-statement? condition ) statement
  - if constexpr? ( init-statement? condition ) statement else statement
  - if !? consteval compound-statement
  - if !? consteval compound-statement else statement
  - switch ( init-statement? condition ) statement
- iteration-statement:
  - while ( condition ) statement
  - do statement while ( expression ) ;
  - for ( init-statement condition? ; expression? ) statement
  - for ( init-statement? for-range-declaration : for-range-initializer ) statement
- for-range-declaration:
  - attribute-specifier\* decl-specifier+ declarator
  - attribute-specifier\* decl-specifier+ ref-qualifier? [ identifier-list ]
- for-range-initializer:
  - expr-or-braced-init-list
- jump-statement:
  - break ;
  - continue ;
  - return expr-or-braced-init-list? ;
  - coroutine-return-statement
  - goto identifier ;
- coroutine-return-statement:
  - co_return expr-or-braced-init-list? ;
- declaration-statement:
  - block-declaration

### A.7 Declarations

- declaration:
  - name-declaration
  - special-declaration
- name-declaration:
  - block-declaration
  - nodeclspec-function-declaration
  - function-definition
  - template-declaration
  - deduction-guide
  - linkage-specification
  - namespace-definition
  - empty-declaration
  - attribute-declaration
  - module-import-declaration
- special-declaration:
  - explicit-instantiation
  - explicit-specialization
  - export-declaration
- block-declaration:
  - simple-declaration
  - asm-declaration
  - namespace-alias-definition
  - using-declaration
  - using-enum-declaration
  - using-directive
  - static_assert-declaration
  - alias-declaration
  - opaque-enum-declaration
- nodeclspec-function-declaration:
  - attribute-specifier\* declarator ;
- alias-declaration:
  - using identifier attribute-specifier\* = defining-type-id ;
- simple-declaration:
  - decl-specifier+ init-declarator-list? ;
  - attribute-specifier+ decl-specifier+ init-declarator-list ;
  - attribute-specifier\* decl-specifier+ ref-qualifier? [ identifier-list ] initializer ;
- static_assert-declaration:
  - static_assert ( constant-expression ) ;
  - static_assert ( constant-expression , string-literal ) ;
- empty-declaration:
  - ;
- attribute-declaration:
  - attribute-specifier+ ;
- decl-specifier:
  - storage-class-specifier
  - defining-type-specifier
  - function-specifier
  - friend
  - typedef
  - constexpr
  - consteval
  - constinit
  - inline
- decl-specifier-seq:
  - decl-specifier attribute-specifier-seq?
  - decl-specifier decl-specifier-seq
- storage-class-specifier:
  - static
  - thread_local
  - extern
  - mutable
- function-specifier:
  - virtual
  - explicit-specifier
- explicit-specifier:
  - explicit ( constant-expression )
  - explicit
- type-specifier:
  - simple-type-specifier
  - elaborated-type-specifier
  - typename-specifier
  - cv-qualifier
- defining-type-specifier:
  - type-specifier
  - class-specifier
  - enum-specifier
- simple-type-specifier:
  - nested-name-specifier? type-name
  - nested-name-specifier template simple-template-id
  - decltype-specifier
  - placeholder-type-specifier
  - nested-name-specifier? template-name
  - char
  - char8_t
  - char16_t
  - char32_t
  - wchar_t
  - bool
  - short
  - int
  - long
  - signed
  - unsigned
  - float
  - double
  - void
- type-name:
  - class-name
  - enum-name
  - typedef-name
- elaborated-type-specifier:
  - class-key attribute-specifier\* nested-name-specifier? identifier
  - class-key simple-template-id
  - class-key nested-name-specifier template? simple-template-id
  - enum nested-name-specifier? identifier
- decltype-specifier:
  - decltype ( expression )
- placeholder-type-specifier:
  - type-constraint? auto
  - type-constraint? decltype ( auto )
- init-declarator-list:
  - init-declarator
  - init-declarator-list , init-declarator
- init-declarator:
  - declarator initializer?
  - declarator requires-clause
- declarator:
  - ptr-declarator
  - noptr-declarator parameters-and-qualifiers trailing-return-type ;
- ptr-declarator:
  - noptr-declarator
  - ptr-operator ptr-declarator
- noptr-declarator:
  - declarator-id attribute-specifier\*
  - noptr-declarator parameters-and-qualifiers
  - noptr-declarator [ constant-expression? ] attribute-specifier\*
  - ( ptr-declarator )
- parameters-and-qualifiers:
  - ( parameter-declaration-clause ) cv-qualifier\* ref-qualifier? noexcept-specifier? attribute-specifier\*
- trailing-return-type:
  - -> type-id
- ptr-operator:
  - \* attribute-specifier* cv-qualifier*
  - & attribute-specifier\*
  - && attribute-specifier\*
  - nested-name-specifier \* attribute-specifier\* cv-qualifier\*
- cv-qualifier-seq:
  - cv-qualifier cv-qualifier\*
- cv-qualifier:
  - const
  - volatile
- ref-qualifier:
  - &
  - &&
- declarator-id:
  - ...? id-expression
- type-id:
  - type-specifier+ abstract-declarator?
- defining-type-id:
  - defining-type-specifier+ abstract-declarator?
- abstract-declarator:
  - ptr-abstract-declarator
  - noptr-abstract-declarator? parameters-and-qualifiers trailing-return-type
  - abstract-pack-declarator
- ptr-abstract-declarator:
  - noptr-abstract-declarator
  - ptr-operator ptr-abstract-declarator?
- noptr-abstract-declarator:
  - noptr-abstract-declarator? parameters-and-qualifiers
  - noptr-abstract-declarator? [ constant-expression? ] attribute-specifier\*
  - ( ptr-abstract-declarator )
- abstract-pack-declarator:
  - noptr-abstract-pack-declarator
  - ptr-operator abstract-pack-declarator
- noptr-abstract-pack-declarator:
  - noptr-abstract-pack-declarator parameters-and-qualifiers
  - noptr-abstract-pack-declarator [ constant-expression? ] attribute-specifier\*
  - ...
- parameter-declaration-clause:
  - parameter-declaration-list? ...?
  - parameter-declaration-list , ...
- parameter-declaration-list:
  - parameter-declaration
  - parameter-declaration-list , parameter-declaration
- parameter-declaration:
  - attribute-specifier\* this? decl-specifier+ declarator
  - attribute-specifier\* decl-specifier+ declarator = initializer-clause
  - attribute-specifier\* this? decl-specifier+ abstract-declarator?
  - attribute-specifier\* decl-specifier+ abstract-declarator? = initializer-clause
- initializer:
  - brace-or-equal-initializer
  - ( expression-list )
- brace-or-equal-initializer:
  - = initializer-clause
  - braced-init-list
- initializer-clause:
  - assignment-expression
  - braced-init-list
- braced-init-list:
  - { initializer-list ,? }
  - { designated-initializer-list ,? }
  - { }
- initializer-list:
  - initializer-clause ...?
  - initializer-list , initializer-clause ...?
- designated-initializer-list:
  - designated-initializer-clause
  - designated-initializer-list , designated-initializer-clause
- designated-initializer-clause:
  - designator brace-or-equal-initializer
- designator:
  - . identifier
- expr-or-braced-init-list:
  - expression
  - braced-init-list
- function-definition:
  - attribute-specifier* decl-specifier* declarator virt-specifier\* function-body
  - attribute-specifier* decl-specifier* declarator requires-clause function-body
- function-body:
  - ctor-initializer? compound-statement
  - function-try-block
  - = default ;
  - = delete ;
- enum-specifier:
  - enum-head { enumerator-list? }
  - enum-head { enumerator-list , }
- enum-head:
  - enum-key attribute-specifier\* enum-head-name? enum-base?
- enum-head-name:
  - nested-name-specifier? identifier
- opaque-enum-declaration:
  - enum-key attribute-specifier\* enum-head-name enum-base? ;
- enum-key:
  - enum
  - enum class
  - enum struct
- enum-base:
  - : type-specifier+
- enumerator-list:
  - enumerator-definition
  - enumerator-list , enumerator-definition
- enumerator-definition:
  - enumerator
  - enumerator = constant-expression
- enumerator:
  - identifier attribute-specifier\*
- using-enum-declaration:
  - using enum using-enum-declarator ;
- using-enum-declarator:
  - nested-name-specifier? identifier
  - nested-name-specifier? simple-template-id
- namespace-definition:
  - named-namespace-definition
  - unnamed-namespace-definition
  - nested-namespace-definition
- named-namespace-definition:
  - inline? namespace attribute-specifier\* identifier { namespace-body }
- unnamed-namespace-definition:
  - inline? namespace attribute-specifier\* { namespace-body }
- nested-namespace-definition:
  - namespace enclosing-namespace-specifier :: inline? identifier { namespace-body }
- enclosing-namespace-specifier:
  - identifier
  - enclosing-namespace-specifier :: inline? identifier
- namespace-body:
  - declaration\*
- namespace-alias-definition:
  - namespace identifier = qualified-namespace-specifier ;
- qualified-namespace-specifier:
  - nested-name-specifier? namespace-name
- using-directive:
  - attribute-specifier\* using namespace nested-name-specifier? namespace-name ;
- using-declaration:
  - using using-declarator-list ;
- using-declarator-list:
  - using-declarator ...?
  - using-declarator-list , using-declarator ...?
- using-declarator:
  - typename? nested-name-specifier unqualified-id
- asm-declaration:
  - attribute-specifier\* asm ( string-literal ) ;
- linkage-specification:
  - extern string-literal { declaration\* }
  - extern string-literal name-declaration
- attribute-specifier-seq:
  - attribute-specifier\* attribute-specifier
- attribute-specifier:
  - [ [ attribute-using-prefix? attribute-list ] ]
  - alignment-specifier
- alignment-specifier:
  - alignas ( type-id ...? )
  - alignas ( constant-expression ...? )
- attribute-using-prefix:
  - using attribute-namespace :
- attribute-list:
  - attribute?
  - attribute-list , attribute?
  - attribute ...
  - attribute-list , attribute ...
- attribute:
  - attribute-token attribute-argument-clause?
- attribute-token:
  - identifier
  - attribute-scoped-token
- attribute-scoped-token:
  - attribute-namespace :: identifier
- attribute-namespace:
  - identifier
- attribute-argument-clause:
  - ( balanced-token\* )
- balanced-token:
  - ( balanced-token\* )
  - [ balanced-token* ]
  - { balanced-token\* }
  - any token other than a parenthesis, a bracket, or a brace

### A.8 Modules

- module-declaration:
  - export-keyword? module-keyword module-name module-partition? attribute-specifier\* ;
- module-name:
  - module-name-qualifier? identifier
- module-partition:
  - : module-name-qualifier? identifier
- module-name-qualifier:
  - identifier .
  - module-name-qualifier identifier .
- export-declaration:
  - export name-declaration
  - export { declaration\* }
  - export-keyword module-import-declaration
- module-import-declaration:
  - import-keyword module-name attribute-specifier\* ;
  - import-keyword module-partition attribute-specifier ;
  - import-keyword header-name attribute-specifier\* ;
- global-module-fragment:
  - module-keyword ; declaration\*
- private-module-fragment:
  - module-keyword : private ; declaration\*

### A.9 Classes

- class-specifier:
  - class-head { member-specification? }
- class-head:
  - class-key attribute-specifier\* class-head-name class-virt-specifier? base-clause?
  - class-key attribute-specifier\* base-clause?
- class-head-name:
  - nested-name-specifier? class-name
- class-virt-specifier:
  - final
  - < final >
- class-key:
  - class
  - struct
  - union
- member-specification:
  - member-declaration member-specification?
  - access-specifier : member-specification?
- member-declaration:
  - attribute-specifier* decl-specifier* member-declarator\* ;
  - function-definition
  - using-declaration
  - using-enum-declaration
  - static_assert-declaration
  - template-declaration
  - explicit-specialization
  - deduction-guide
  - alias-declaration
  - opaque-enum-declaration
  - empty-declaration
- member-declarator-list:
  - member-declarator
  - member-declarator-list , member-declarator
- member-declarator:
  - declarator virt-specifier\* pure-specifier?
  - declarator requires-clause
  - declarator brace-or-equal-initializer?
  - identifier? attribute-specifier\* : constant-expression brace-or-equal-initializer?
- virt-specifier:
  - override
  - final
- pure-specifier:
  - = 0
- conversion-function-id:
  - operator conversion-type-id
- conversion-type-id:
  - type-specifier+ conversion-declarator?
- conversion-declarator:
  - ptr-operator conversion-declarator?
- base-clause:
  - : base-specifier-list
- base-specifier-list:
  - : base-specifier ...?
  - base-specifier-list , base-specifier ...?
- base-specifier:
  - attribute-specifier\* class-or-decltype
  - attribute-specifier\* virtual access-specifier? class-or-decltype
  - attribute-specifier\* access-specifier virtual? class-or-decltype
- class-or-decltype:
  - nested-name-specifier? type-name
  - nested-name-specifier template simple-template-id
  - decltype-specifier
- access-specifier:
  - private
  - protected
  - public
- ctor-initializer:
  - : mem-initializer-list
- mem-initializer-list:
  - mem-initializer ...?
  - mem-initializer-list , mem-initializer ...?
- mem-initializer:
  - mem-initializer-id ( expression-list? )
  - mem-initializer-id braced-init-list
- mem-initializer-id:
  - class-or-decltype
  - identifier

### A.10 Overloading

- operator-function-id:
  - operator operator
- operator: one of
  - new delete new[] delete[] co*await ( ) [ ] -> ->*\* ~ ! + - \* / % ^ & | = += -= \*= /= %= ^= &= |= == != < > <= >= <=> && || << >> <<= >>= ++ -- ,
- literal-operator-id:
  - operator string-literal identifier
  - operator user-defined-string-literal

### A.11 Templates

- template-declaration:
  - template-head declaration
  - template-head concept -definition
- template-head:
  - template < template-parameter-list > requires-clause?
- template-parameter-list:
  - template-parameter
  - template-parameter-list , template-parameter
- requires-clause:
  - requires constraint-logical-or-expression
- constraint-logical-or-expression:
  - constraint-logical-and-expression
  - constraint-logical-or-expression || constraint-logical-and-expression
- constraint-logical-and-expression:
  - primary-expression
  - constraint-logical-and-expression && primary-expression
- template-parameter:
  - type-parameter
  - parameter-declaration
- type-parameter:
  - type-parameter-key ...? identifier?
  - type-parameter-key identifier? = type-id
  - type-constraint ...? identifier?
  - type-constraint identifier? = type-id
  - template-head type-parameter-key ...? identifier?
  - template-head type-parameter-key identifier? = id-expression
- type-parameter-key:
  - class
  - typename
- type-constraint:
  - nested-name-specifier? concept-name
  - nested-name-specifier? concept-name < template-argument-list? >
- template-id:
  - simple-template-id
  - operator-function-id < template-argument-list? >
  - literal-operator-id < template-argument-list? >
- template-argument-list:
  - template-argument ...?
  - template-argument-list , template-argument? ...?
- template-argument:
  - constant-expression
  - type-id
  - id-expression
- constraint-expression:
  - logical-or-expression
- deduction-guide:
  - explicit-specifier? template-name ( parameter-declaration-clause ) -> simple-template-id ;
- concept-definition:
  - concept concept-name attribute-specifier\* = constraint-expression ;
- concept-name:
  - identifier
- typename-specifier:
  - typename nested-name-specifier identifier
  - typename nested-name-specifier template? simple-template-id
- explicit-instantiation:
  - extern? template declaration
- explicit-specialization:
  - template < > declaration

### A.12 Exception handling

- try-block:
  - try compound-statement handler-seq
- function-try-block:
  - try ctor-initializer? compound-statement handler-seq
- handler-seq:
  - handler handler\*
- handler:
  - catch ( exception-declaration ) compound-statement
- exception-declaration:
  - attribute-specifier\* type-specifier+ declarator
  - attribute-specifier\* type-specifier+ abstract-declarator?
  - ...
- noexcept-specifier:
  - noexcept ( constant-expression )
  - noexcept

### A.13 Preprocessing directives

- preprocessing-file:
  - group?
  - module-file
- module-file:
  - pp-global-module-fragment? pp-module group? pp-private-module-fragment?
  - pp-global-module-fragment:
  - module ; new-line group?
- pp-private-module-fragment:
  - module : private ; new-line group?
- group:
  - group-part
  - group group-part
- group-part:
  - control-line
  - if-section
  - text-line
  - \# conditionally-supported-directive
- control-line:
  - \# include pp-tokens new-line
  - pp-import
  - \# define identifier replacement-list new-line
  - \# define identifier lparen identifier-list? ) replacement-list new-line
  - \# define identifier lparen ... ) replacement-list new-line
  - \# define identifier lparen identifier-list , ... ) replacement-list new-line
  - \# undef identifier new-line
  - \# line pp-tokens new-line
  - \# error pp-tokens? new-line
  - \# warning pp-tokens? new-line
  - \# pragma pp-tokens? new-line
  - \# new-line
- if-section:
  - if-group elif-groups? else-group? endif-line
- if-group:
  - \# if constant-expression new-line group?
  - \# ifdef identifier new-line group?
  - \# ifndef identifier new-line group?
- elif-groups:
  - elif-group
  - elif-groups elif-group
- elif-group:
  - \# elif constant-expression new-line group?
  - \# elifdef identifier new-line group?
  - \# elifndef identifier new-line group?
- else-group:
  - \# else new-line group?
- endif-line:
  - \# endif new-line
- text-line:
  - pp-tokens? new-line
- conditionally-supported-directive:
  - pp-tokens new-line
- lparen:
  - a ( character not immediately preceded by whitespace
- identifier-list:
  - identifier
  - identifier-list , identifier
- replacement-list:
  - pp-tokens?
- pp-tokens:
  - preprocessing-token
  - pp-tokens preprocessing-token
- new-line:
  - the new-line character
- defined-macro-expression:
  - defined identifier
  - defined ( identifier )
- h-preprocessing-token:
  - any preprocessing-token other than >
- h-pp-tokens:
  - h-preprocessing-token
  - h-pp-tokens h-preprocessing-token
- header-name-tokens:
  - string-literal
  - < h-pp-tokens >
- has-include-expression:
  - \_\_has_include ( header-name )
  - \_\_has_include ( header-name-tokens )
- has-attribute-expression:
  - \_\_has_cpp_attribute ( pp-tokens )
- pp-module:
  - export? module pp-tokens? ; new-line
- pp-import:
  - export? import header-name pp-tokens? ; new-line
  - export? import header-name-tokens pp-tokens? ; new-line
  - export? import pp-tokens ; new-line
- va-opt-replacement:
  - \_\_VA_OPT\_\_ ( pp-tokens? )

## Implementation defined

- TODO: List of implementation-defined

- \#pragma: Ignores any #pragma directive currently.
- additional execution policies supported by parallel algorithms: Nothing
- additional file_type enumerators for file systems supporting additional types of file: Defined by library.
- additional formats for time_get::do_get_date: Defined by library.
- additional supported forms of preprocessing directive: Nothing
- algorithms for producing the standard random number distributions: Defined by library.
- alignment: 8
- alignment additional values: TBD
- alignment of bit-fields within a class object: TBD
- allocation of bit-fields within a class object: TBD
- any use of an invalid pointer other than to perform indirection or deallocate: TBD
- argument values to construct basic_ios::failure: Defined by library.
- assignability of placeholder objects: TBD
- behavior of iostream classes when traits::pos_type is not streampos or when traits::off_type is not streamoff: Defined by library.
- behavior of non-standard attributes: Ignores them.
- bits in a byte: 8
- choice of larger or smaller value of floating literal: TBD
- concatenation of some types of string literals: TBD
- conversions between pointers and integers: TBD
- converting characters from source character set to execution character set: Assumes both the character sets are the same, so conversion is unnecessasry. [!]
- converting function pointer to object pointer and vice versa: TBD
- default configuration of a pool: TBD
- default next_buffer_size for a monotonic_buffer_resource: TBD
- default number of buckets in unordered_map: Defined by library.
- default number of buckets in unordered_multimap: Defined by library.
- default number of buckets in unordered_multiset: Defined by library.
- default number of buckets in unordered_set: Defined by library.
- defining main in freestanding environment: Yes, it is in freestanding environmnet currently.
- definition and meaning of **STDC**: The macro is not defined.
- definition and meaning of **STDC_VERSION**: The macro is not defined.
- definition of NULL: The NULL is defined in the <cstddef> header [!]
- derived type for typeid: TBD
- diagnostic message: It is minimal currently. [!]
- dynamic initialization of static inline variables before main: TBD
- dynamic initialization of static variables before main: TBD
- dynamic initialization of thread-local variables before entry: TBD
- effect of calling associated Laguerre polynomials with n >= 128 or m >= 128: TBD
- effect of calling associated Legendre polynomials with l >= 128: TBD
- effect of calling basic_filebuf::setbuf with nonzero arguments: Defined by library
- effect of calling basic_filebuf::sync when a get area exists: Defined by library
- effect of calling basic_streambuf::setbuf with nonzero arguments: Defined by library
- effect of calling cylindrical Bessel functions of the first kind with nu >= 128: Defined by library
- effect of calling cylindrical Neumann functions with nu >= 128: Defined by library
- effect of calling Hermite polynomials with n >= 128: Defined by library
- effect of calling ios_base::sync_with_stdio after any input or output operation on standard streams: Defined by library
- effect of calling irregular modified cylindrical Bessel functions with nu >= 128: Defined by library
- effect of calling Laguerre polynomials with n >= 128: Defined by library
- effect of calling Legendre polynomials with l >= 128: Defined by library
- effect of calling regular modified cylindrical Bessel functions with nu >= 128: Defined by library
- effect of calling spherical associated Legendre functions with l >= 128: Defined by library
- effect of calling spherical Bessel functions with n >= 128: Defined by library
- effect of calling spherical Neumann functions with n >= 128: Defined by library
- effect of filesystem::copy: Defined by library
- effect on C locale of calling locale::global: Defined by library
- encoding of universal character name not in execution character set: Compile failed [!]
- error_category for errors originating outside the operating system: Defined by library
- exception type when random_device constructor fails: Defined by library
- exception type when random_device::operator() fails: Defined by library
- exception type when shared_ptr constructor fails: Defined by library
- exceptions thrown by standard library functions that have a potentially-throwing
- exception specification: Ignored
- execution character set and execution wide-character set: The first character set is UTF-8, wide-character set is UTF-16(BE).
- exit status: EXIT_SUCCESS is zero, EXIT_FAILURE is -1. [!]
- extended signed integer types: TBD
- file type of the file argument of filesystem::status: Defined by library
- formatted character sequence generated by time_put::do_put in C locale: Defined by library
- forward progress guarantees for implicit threads of parallel algorithms (if not defined for thread): Defined by library
- growth factor for monotonic_buffer_resource: Defined by library
- headers for freestanding implementation: Provides the following:
  - atomic
  - cfloat
  - climits
  - cstdarg
  - cstddef
  - cstdint
  - cstdlib(minimal)
  - exception
  - initializer_list
  - limits
  - new
  - typeinfo
  - typet_traits
  - version (optional)
- how random_device::operator() generates values: Defined by library
- interactive device: TBD
- interpretation of the path character sequence with format path::auto_format: Defined by library
- largest supported value to configure the largest allocation satisfied directly by a pool: TBD
- largest supported value to configure the maximum number of blocks to replenish a pool: TBD
- linkage of main: Default "C++" linlkage [!]
- linkage of names from C standard library: Default "C++" linkage [!]
- linkage of objects between C++ and other languages: The "C" linkage [!]
- locale names: Defined locals are the following: [!]
  - "": system native
  - "C": The C language comatible
  - "en_US": English in USA.
  - "ja_JP": Japanese in Japan.
- lvalue-to-rvalue conversion of an invalid pointer value: TBD
- manner of search for included source file: In related path from including source file.
- mapping from physical source file characters to basic source character set: Non basic source character is dealt as universal character. The CR folloed by LF is dealt as single LF as new-line.
- mapping header name to header or external source file: TBD
- mapping of pointer to integer: TBD
- mapping physical source file characters to basic source character set:
  - assumes source file characters are in UTF-8.
  - deals CR-LF pair as the same as the one new-line character, single LF only.
- mapping to message when calling messages::do_get: Defined by library
- maximum depth of recursive template instantiations: TBD
- maximum size of an allocated object: TBD
- meaning of ’, \, /\*, or // in a q-char-sequence or an h-char-sequence: TBD
- meaning of asm declaration: Inoine assembly in Intel-style format.
- meaning of attribute declaration: TBD
- meaning of dot-dot in root-directory: Defined by library
- negative value of character literal in preprocessor: TBD
- nesting limit for #include directives: TBD
- NTCTS in basic_ostream<charT, traits>& operator<<(nullptr_t): Defined by library
- number of placeholders for bind expressions: TBD
- number of threads in a program under a freestanding implementation: TBD
- numeric values of character literals in #if directives: UTF-8 (ASCII)
- operating system on which implementation depends: POSIX or Win32 [!]
- parameters to main: The first is always program name. Following parameters are arguments of the program if exists.
- passing argument of class type through ellipsis: TBD
- physical source file characters: UTF-8
- presence and meaning of native_handle_type and native_handle: Defined by library
- range defined for character literals: 0-127
- rank of extended signed integer type: TBD
- representation of char: TBD
- required libraries for freestanding implementation: TBD
- resource limits on a message catalog: TBD
- result of filesystem::file_size: Definedd by library
- result of inexact floating-point conversion: TBD
- result of right shift of negative value: TBD
- return value of bad_alloc::what: Definedd by library
- return value of bad_any_access::what: Definedd by library
- return value of bad_array_new_length::what: Definedd by library
- return value of bad_cast::what: Definedd by library
- return value of bad_exception::what: Definedd by library
- return value of bad_function_call::what: Definedd by library
- return value of bad_optional_access::what: Definedd by library
- return value of bad_typeid::what: Definedd by library
- return value of bad_variant_access::what: Definedd by library
- return value of bad_weak_ptr::what: Definedd by library
- return value of char_traits<char16_t>::eof: Definedd by library
- return value of char_traits<char32_t>::eof: Definedd by library
- return value of exception::what: Defined by library
- return value of type_info::name(): Full-qualified type name.
- search locations for "" header: The priorities are as follows: descending order of lines, and descending order of items within the same line.
  - directory where compiling source file exists in.
  - set using -I argument if exists.
  - set as the INCLUDES environment variable if defined.
  - priset of this compiler: /usr/local/include, /usr/include
- search locations for <> header: The priorities are as follows: descending order of lines, and descending order of items within the same line.
  - set using -I argument if exists.
  - set as the INCLUDES environment variable if defined.
  - priset of this compiler: /usr/local/include, /usr/include
- semantics and default value of token parameter to random_device constructor: Defined by library
- semantics of an access through a volatile glvalue: TBD
- semantics of linkage specification on templates: TBD
- semantics of linkage specifiers: TBD
- semantics of non-standard escape sequences: Invalid character
- semantics of parallel algorithms invoked with implementation-defined execution policies: TBD
- sequence of places searched for a header: TBD
- set of character types that iostreams templates can be instantiated for: Defined by library
- signedness of char: signed
- sizeof applied to fundamental types other than char, signed char, and unsigned char: They are the followings:
  - short: 2
  - int: 4
  - long: 8
  - long long: 8
  - float: 2
  - double: 4
  - long double: 8
  - wchar_t: 2
  - char8_t: 1
  - char16_t: 2
  - char32_t: 4
- stack unwinding before call to std::terminate(): TBD
- start-up and termination in freestanding environment: TBD
- string resulting from **func**: [!]
- support for extended alignment: Unsupported [!]
- support for extended alignments: Unsupported [!]
- support for over-aligned types: Unsupported [!]
- supported multibyte character encoding rules: UTF-8
- supported root-names in addition to any operating system dependent root-names: The '/' always maens root-name.
- text of **DATE** when date of translation is not available: "Non 99 9999"
- text of **TIME** when time of translation is not available: 99:99:99"
- threads and program points at which deferred dynamic initialization is performed: TBD
- type of a directory-like file: type of array::const_iterator: Defined by library
- type of array::iterator: Defined by library
- type of basic_string::const_iterator: Defined by library
- type of basic_string::iterator: Defined by library
- type of basic_string_view::const_iterator: Defined by library
- type of default_random_engine: Defined by library
- type of deque::const_iterator: Defined by library
- type of deque::iterator: Defined by library
- type of filesystem trivial clock: Defined by library
- type of forward_list::const_iterator: Defined by library
- type of forward_list::iterator: Defined by library
- type of list::const_iterator: Defined by library
- type of list::iterator: Defined by library
- type of map::const_iterator: Defined by library
- type of map::iterator: Defined by library
- type of multimap::const_iterator: Defined by library
- type of multimap::iterator: Defined by library
- type of multiset::const_iterator: Defined by library
- type of multiset::iterator: Defined by library
- type of ptrdiff_t: This compiler assumes "long long" although defined by library
- type of regex_constants::error_type: Defined by library
- type of regex_constants::match_flag_type: Defined by library
- type of set::const_iterator: Defined by library
- type of set::iterator: Defined by library
- type of size_t: This compiler assumes "unsigned long long" although defined by library.
- type of streamoff: Defined by library
- type of streampos: Defined by library
- type of syntax_option_type: Defined by library
- type of u16streampos: Defined by library
- type of u32streampos: Defined by library
- type of unordered_map::const_iterator: Defined by library
- type of unordered_map::const_local_iterator: Defined by library
- type of unordered_map::iterator: Defined by library
- type of unordered_map::local_iterator: Defined by library
- type of unordered_multimap::const_iterator: Defined by library
- type of unordered_multimap::const_local_iterator: Defined by library
- type of unordered_multimap::iterator: Defined by library
- type of unordered_multimap::local_iterator: Defined by library
- type of unordered_multiset::const_iterator: Defined by library
- type of unordered_multiset::const_local_iterator: Defined by library
- type of unordered_multiset::iterator: Defined by library
- type of unordered_multiset::local_iterator: Defined by library
- type of unordered_set::const_iterator: Defined by library
- type of unordered_set::const_local_iterator: Defined by library
- type of unordered_set::iterator: Defined by library
- type of unordered_set::local_iterator: Defined by library
- type of vector::const_iterator: Defined by library
- type of vector::iterator: Defined by library
- type of vector<bool>::const_iterator: Defined by library
- type of vector<bool>::iterator: Defined by library
- type of wstreampos: Defined by library
- underlying type for enumeration: TBD
- value of bit-field that cannot represent assigned value: TBD
- incremented value: TBD
- initializer: TBD
- value of character literal outside range of corresponding type: TBD
- value of ctype<char>::table_size: Defined by library [!]
- value of multicharacter literal: Unsupported
- value of pow(0,0): Defined bt library
- value of result of inexact integer to floating-point conversion: TBD
- value of result of unsigned to signed conversion: TBD
- value of wide-character literal containing multiple characters: Invalid character
- value of wide-character literal with single c-char that is not in execution wide-character set: TBD
- value representation of floating-point types: 0xXXXXXXXX
- value representation of pointer types: 0xXXXXXXXX
- values of a trivially copyable type: TBD
- values of various ATOMIC\_...\_LOCK_FREE macros: TBD
- whether <cfenv> functions can be used to manage floating-point status: TBD
- whether a given atomic type’s operations are always lock free: Defined by library
- whether an implementation has relaxed or strict pointer safety: TBD
- whether functions from Annex K of the C standard library are declared when C++ headers are included: TBD
- whether get_pointer_safety returns pointer_safety::relaxed or pointer_safety::preferred if the implementation has relaxed pointer safety: TBD
- whether locale object is global or per-thread: Global
- whether pragma FENV_ACCESS is supported: Unsupported
- whether rand may introduce a data race: TBD
- whether sequence pointers are copied by basic_filebuf move constructor: Defined by library
- whether sequence pointers are copied by basic_stringbuf move constructor: Defined by library
- whether source of translation units must be available to locate template definitions: TBD
- whether stack is unwound before calling std::terminate() when a noexcept specification is violated: TBD
- whether the lifetime of a parameter ends when the callee returns or at the end of the enclosing full-expression: TBD
- whether the thread that executes main and the threads created by std::thread provide concurrent forward progress guarantees: TBD
- whether time_get::do_get_year accepts two-digit year numbers: Defined by library
- whether values are rounded or truncated to the required precision when converting between time_t values and time_point objects: Defined by library
- whether variant supports over-aligned types: Defined by library
- which functions in the C++ standard library may be recursively reentered: Defined by library.
- which scalar types have unique object representations: TBD

- hardware destructive interference size: 4
- hardware constructive interference size: 4
